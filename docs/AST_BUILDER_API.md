# easy_pc AST Builder API

The `easy_pc` library provides a robust and flexible API for building Abstract Syntax Trees (ASTs) directly from the Concrete Parse Tree (CPT) generated by its parsers. This API simplifies AST construction by abstracting away stack management and tree traversal, allowing users to focus on defining how specific grammar rules translate into meaningful AST nodes.

## Core Concepts

The AST builder operates on a callback-driven model, where user-defined "action handlers" are invoked at specific points during the CPT traversal to construct the AST.

### 1. `epc_ast_hook_registry_t`

This structure acts as the central configuration for the AST builder. It holds pointers to all user-defined callback functions, including semantic action handlers, a node freeing function, and optional enter/exit node callbacks.

### 2. Semantic Action Callbacks (`epc_ast_action_cb`)

These are the primary handlers for AST construction. Each callback corresponds to a specific semantic action ID defined in your grammar.

```c
typedef void (*epc_ast_action_cb)(
    epc_ast_builder_ctx_t * ctx,
    epc_cpt_node_t * node,
    void * * children,
    int count,
    void * user_data
);
```

*   `ctx`: The AST builder context. Use this to push newly created AST nodes onto the internal stack or report errors.
*   `node`: The `epc_cpt_node_t` (from the CPT) that triggered this action. Provides access to matched content, name, and other parse details.
*   `children`: An array of `void*` pointers, representing the AST nodes returned by the children of the current CPT node.
*   `count`: The number of items in the `children` array.
*   `user_data`: An optional user-defined data pointer passed through the entire AST building process.

### 3. Node Freeing Callback (`epc_ast_node_free_cb`)

This crucial callback is responsible for releasing the memory associated with your custom AST node types. It is called automatically by the AST builder during stack unwinding (both normal completion and error recovery) to prevent memory leaks.

```c
typedef void (*epc_ast_node_free_cb)(void * node, void * user_data);
```

*   `node`: A `void*` pointer to the AST node to be freed.
*   `user_data`: The same user-defined data pointer passed during AST initialization.

### 4. Pushing AST Nodes (`epc_ast_push`)

Within an action handler, use this function to push a newly created AST node onto the builder's internal stack. This node will then be available as a `child` to subsequent parent action handlers.

```c
EASY_PC_API void epc_ast_push(epc_ast_builder_ctx_t * ctx, void * node);
```

### 5. Reporting Errors (`epc_ast_builder_set_error`)

Action handlers can report errors encountered during AST construction using this function.

```c
EASY_PC_API void epc_ast_builder_set_error(epc_ast_builder_ctx_t * ctx, const char * format, ...);
```

## How to Use the API

### Step 1: Define Your AST Node Structure and Semantic Actions

First, define the structure of your AST nodes (e.g., `ast_node_t` with a `union` for different node types) and an enumeration for your semantic actions (e.g., `ast_action_type_t`).

```c
// ast.h (Example)
typedef enum {
    AST_NODE_TYPE_NUMBER,
    AST_NODE_TYPE_OPERATOR,
    // ... other node types
} ast_node_type_t;

typedef struct ast_node_t {
    ast_node_type_t type;
    union {
        double number_value;
        char operator_char;
        // ... other node data
    } data;
} ast_node_t;

// ast_action_type_t (Example)
typedef enum {
    AST_ACTION_NONE,
    AST_ACTION_CREATE_NUMBER,
    AST_ACTION_CREATE_OPERATOR,
    AST_ACTION_BUILD_BINARY_EXPRESSION,
    AST_ACTION_MAX, // Always include a MAX for registry sizing
} ast_action_type_t;
```

### Step 2: Implement Your Node Freeing Function

Create a function that can recursively free all memory associated with your AST nodes. This function *must* match the `epc_ast_node_free_cb` signature.

```c
// my_ast_actions.c (Example)
void
my_ast_node_free(void * node_ptr, void * user_data)
{
    (void)user_data; // User data not used in this example
    ast_node_t * node = (ast_node_t *)node_ptr;

    if (node == NULL) {
        return;
    }

    switch(node->type) {
        case AST_NODE_TYPE_NUMBER:
        case AST_NODE_TYPE_OPERATOR:
            // Leaf nodes, no children to free
            break;
        case AST_NODE_TYPE_BINARY_EXPRESSION:
            my_ast_node_free(node->data.expression.left, user_data);
            my_ast_node_free(node->data.expression.operator_node, user_data);
            my_ast_node_free(node->data.expression.right, user_data);
            break;
        // ... handle other node types and their children
    }
    free(node);
}
```

### Step 3: Implement Your Semantic Action Handlers

For each `AST_ACTION` you defined, create a corresponding `epc_ast_action_cb` function.

#### Example: Creating a Number Node

This handler creates an `AST_NODE_TYPE_NUMBER` from the CPT node's semantic content.

```c
// my_ast_actions.c (Example)
static void
create_number_action(
    epc_ast_builder_ctx_t * ctx,
    epc_cpt_node_t * node,
    void * * children, // No children for a terminal node
    int count,
    void * user_data
)
{
    ast_node_t * num_node = (ast_node_t *)calloc(1, sizeof(*num_node));
    if (num_node == NULL) {
        for (int i = 0; i < count; i++) {
            my_ast_node_free(children[i], user_data);
        }
        epc_ast_builder_set_error(ctx, "Memory allocation failed for number node");
        return;
    }
    num_node->type = AST_NODE_TYPE_NUMBER;
    num_node->data.number_value = strtod(epc_cpt_node_get_semantic_content(node), NULL);
    epc_ast_push(ctx, num_node);
}
```

#### Example: Building a Binary Expression

This handler combines children (typically `left_operand`, `operator`, `right_operand`) into a new expression node.

```c
// my_ast_actions.c (Example)
static void
build_binary_expression_action(
    epc_ast_builder_ctx_t * ctx,
    epc_cpt_node_t * node,
    void * * children, // Expects [left, operator, right]
    int count,
    void * user_data
)
{
    (void)node;

    if (count != 3) {
        /* Free the children before returning. */
        for (int i = 0; i < count; i++) {
            my_ast_node_free(children[i], user_data);
        }
        epc_ast_builder_set_error(ctx, "Binary expression expects 3 children (left, op, right), got %d", count);
        return;
    }

    ast_node_t * left_operand = (ast_node_t *)children[0];
    ast_node_t * operator_node = (ast_node_t *)children[1];
    ast_node_t * right_operand = (ast_node_t *)children[2];

    if (operator_node == NULL || operator_node->type != AST_NODE_TYPE_OPERATOR) {
        for (int i = 0; i < count; i++) {
            my_ast_node_free(children[i], user_data);
        }
        epc_ast_builder_set_error(ctx, "Expected operator node for binary expression");
        return;
    }

    ast_node_t * expr_node = (ast_node_t *)calloc(1, sizeof(*expr_node));
    if (expr_node == NULL) {
        for (int i = 0; i < count; i++) {
            my_ast_node_free(children[i], user_data);
        }
        epc_ast_builder_set_error(ctx, "Memory allocation failed for expression node");
        return;
    }

    expr_node->type = AST_NODE_TYPE_BINARY_EXPRESSION;
    expr_node->data.expression.left = left_operand;
    expr_node->data.expression.operator_node = operator_node;
    expr_node->data.expression.right = right_operand;

    epc_ast_push(ctx, expr_node);
}
```

### Step 4: Initialize the Hook Registry

Create a function to populate your `epc_ast_hook_registry_t` with all your action handlers and the node freeing function.

```c
// my_ast_actions.h (Example)
#pragma once
// ... includes
void my_ast_hook_registry_init(epc_ast_hook_registry_t * registry, void * user_data);

// my_ast_actions.c (Example)
#include "my_ast_actions.h"
#include "ast.h"
// ... other includes
void
my_ast_hook_registry_init(epc_ast_hook_registry_t * registry, void * user_data)
{
    epc_ast_hook_registry_set_free_node(registry, my_ast_node_free);

    epc_ast_hook_registry_set_action(registry, AST_ACTION_NONE, handle_none_action);
    epc_ast_hook_registry_set_action(registry, AST_ACTION_CREATE_NUMBER, create_number_action);
    epc_ast_hook_registry_set_action(registry, AST_ACTION_CREATE_OPERATOR, create_operator_action);
    epc_ast_hook_registry_set_action(registry, AST_ACTION_BUILD_BINARY_EXPRESSION, build_binary_expression_action);
    // ... register all other action handlers

    // Optionally set an enter_node callback if needed for global context management
    // epc_ast_hook_registry_set_enter_node(registry, my_enter_node_cb);
}
```

### Step 5: Integrate with Your Parser

Finally, when parsing input, create an instance of the registry, initialize it, and pass it to `epc_ast_build` along with the root of your CPT.

```c
// main.c or grammar.c (Example)
#include "easy_pc/easy_pc.h"
#include "easy_pc/easy_pc_ast.h"
#include "my_ast_actions.h" // Your custom AST actions header

// ... parser setup

epc_parse_session_t parse_session = epc_parse_str(your_grammar_root_parser, input_string);

if (!parse_session.result.is_error) {
    epc_ast_hook_registry_t * ast_registry = epc_ast_hook_registry_create(AST_ACTION_MAX);
    if (ast_registry == NULL) {
        // Handle memory error
    } else {
        my_ast_hook_registry_init(ast_registry, NULL); // Pass user data if needed

        epc_ast_result_t ast_build_result = epc_ast_build(parse_session.result.data.success, ast_registry, NULL);

        if (ast_build_result.has_error) {
            fprintf(stderr, "AST build error: %s\n", ast_build_result.error_message);
        } else {
            // AST built successfully, ast_build_result.ast_root is your root AST node
            ast_node_t * root_ast = (ast_node_t *)ast_build_result.ast_root;
            // ... process your AST
            // The root_ast will be freed by epc_ast_build's internal cleanup if an error occurs.
            // If successful, you must free it yourself after use, using your my_ast_node_free.
            my_ast_node_free(root_ast, NULL); // Or let the compiler context cleanup handle it.
        }

        epc_ast_hook_registry_free(ast_registry);
    }
}
// ... cleanup parse_session
epc_parse_session_destroy(&parse_session);
```

### Memory Management for Children in Action Handlers

**CRUCIAL:** When an `epc_ast_action_cb` is invoked, the `children` array contains `void*` pointers to AST nodes that were created by the action handlers of the child CPT nodes. These child nodes **are dynamically allocated and are the responsibility of the current action handler to manage.**

You *MUST* consume these children before your action handler returns. This means:

1.  **Linking to a New Node:** If you are building a composite AST node (e.g., an expression, a list, a function call), you should incorporate these `children` into your new composite node. Once incorporated, the ownership of these `children` is transferred to your new node, and the new node is then pushed onto the stack. Your `epc_ast_node_free_cb` will then be responsible for recursively freeing these children when the composite node is freed.

    *Example (Binary Expression):*
    ```c
    // ... inside build_binary_expression_action
    ast_node_t * left = (ast_node_t *)children[0];
    ast_node_t * op = (ast_node_t *)children[1];
    ast_node_t * right = (ast_node_t *)children[2];

    expr_node->data.expression.left = left;
    expr_node->data.expression.operator_node = op;
    expr_node->data.expression.right = right;
    epc_ast_push(ctx, expr_node); // expr_node now owns left, op, right
    ```

Failure to consume (either link or free) the `children` passed to an action handler will result in memory leaks. The `epc_ast_build` function relies on your action handlers to correctly manage the lifecycle of the AST nodes generated by child CPT rules.
